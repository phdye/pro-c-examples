#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <sqlca.h>

// C string to VARCHAR
void cstr_to_varchar(const char *src, VARCHAR *v, size_t max_vlen) {
    size_t len = strlen(src);
    if (len > max_vlen) len = max_vlen;
    memcpy(v->arr, src, len);
    v->len = (unsigned short)len;
}

// C string to VARCHAR (bounded copy)
void cstr_to_varchar_n(const char *src, size_t n, VARCHAR *v, size_t max_vlen) {
    size_t len = (n > max_vlen) ? max_vlen : n;
    memcpy(v->arr, src, len);
    v->len = (unsigned short)len;
}

// VARCHAR to C string
void varchar_to_cstr(const VARCHAR *v, char *dest, size_t maxlen) {
    size_t len = (v->len < maxlen - 1) ? v->len : maxlen - 1;
    memcpy(dest, v->arr, len);
    dest[len] = '\0';
}

// Copy VARCHAR
void varchar_copy(const VARCHAR *src, VARCHAR *dest, size_t max_dest_len) {
    size_t len = (src->len > max_dest_len) ? max_dest_len : src->len;
    memcpy(dest->arr, src->arr, len);
    dest->len = (unsigned short)len;
}

// Duplicate VARCHAR (heap allocation)
VARCHAR *varchar_strdup(const VARCHAR *src) {
    VARCHAR *copy = (VARCHAR *)malloc(sizeof(VARCHAR) + src->len);
    if (!copy) return NULL;
    copy->len = src->len;
    memcpy(copy->arr, src->arr, src->len);
    return copy;
}

// Length of VARCHAR
size_t varchar_len(const VARCHAR *v) {
    return v->len;
}

// Compare (case-sensitive)
int varchar_cmp(const VARCHAR *v1, const VARCHAR *v2) {
    size_t len = (v1->len < v2->len) ? v1->len : v2->len;
    int cmp = memcmp(v1->arr, v2->arr, len);
    return (cmp != 0) ? cmp : (v1->len - v2->len);
}

// Compare n chars
int varchar_ncmp(const VARCHAR *v1, const VARCHAR *v2, size_t n) {
    size_t len1 = (v1->len < n) ? v1->len : n;
    size_t len2 = (v2->len < n) ? v2->len : n;
    int cmp = memcmp(v1->arr, v2->arr, (len1 < len2 ? len1 : len2));
    return (cmp != 0) ? cmp : (int)(len1 - len2);
}

// Case-insensitive compare
int varchar_icmp(const VARCHAR *v1, const VARCHAR *v2) {
    size_t i, len = (v1->len < v2->len) ? v1->len : v2->len;
    for (i = 0; i < len; i++) {
        int c1 = tolower(v1->arr[i]);
        int c2 = tolower(v2->arr[i]);
        if (c1 != c2) return c1 - c2;
    }
    return v1->len - v2->len;
}

// Case-insensitive n compare
int varchar_nicmp(const VARCHAR *v1, const VARCHAR *v2, size_t n) {
    size_t i, len = (v1->len < n ? v1->len : n);
    for (i = 0; i < len; i++) {
        int c1 = tolower(v1->arr[i]);
        int c2 = tolower(v2->arr[i]);
        if (c1 != c2) return c1 - c2;
    }
    return (int)(v1->len < n ? v1->len : n) - (int)(v2->len < n ? v2->len : n);
}

// Concatenate
void varchar_concat(const VARCHAR *v1, const VARCHAR *v2, VARCHAR *result, size_t max_result_len) {
    size_t l1 = (v1->len > max_result_len) ? max_result_len : v1->len;
    size_t l2 = (v2->len > (max_result_len - l1)) ? (max_result_len - l1) : v2->len;
    memcpy(result->arr, v1->arr, l1);
    memcpy(result->arr + l1, v2->arr, l2);
    result->len = (unsigned short)(l1 + l2);
}

// Concatenate up to n from v2
void varchar_concat_n(const VARCHAR *v1, const VARCHAR *v2, VARCHAR *result, size_t n, size_t max_result_len) {
    size_t l1 = (v1->len > max_result_len) ? max_result_len : v1->len;
    size_t l2 = (v2->len > n) ? n : v2->len;
    if (l1 + l2 > max_result_len) l2 = max_result_len - l1;
    memcpy(result->arr, v1->arr, l1);
    memcpy(result->arr + l1, v2->arr, l2);
    result->len = (unsigned short)(l1 + l2);
}

// Find character
int varchar_index_char(const VARCHAR *v, char c) {
    for (size_t i = 0; i < v->len; i++)
        if (v->arr[i] == c) return (int)i;
    return -1;
}

// Find substring
int varchar_index_of(const VARCHAR *hay, const VARCHAR *needle) {
    if (needle->len == 0 || hay->len < needle->len) return -1;
    for (size_t i = 0; i <= (size_t) (hay->len - needle->len); i++)
        if (memcmp(hay->arr + i, needle->arr, needle->len) == 0)
            return (int)i;
    return -1;
}

// Find first of any character in set
int varchar_index_of_any(const VARCHAR *v, const char *set) {
    for (size_t i = 0; i < v->len; i++)
        if (strchr(set, v->arr[i])) return (int)i;
    return -1;
}

// Length of span (only from set)
size_t varchar_span(const VARCHAR *v, const char *set) {
    size_t i = 0;
    while (i < v->len && strchr(set, v->arr[i])) i++;
    return i;
}

// Length of span (not from set)
size_t varchar_cspan(const VARCHAR *v, const char *reject) {
    size_t i = 0;
    while (i < v->len && !strchr(reject, v->arr[i])) i++;
    return i;
}

// Trim both ends
void varchar_trim(const VARCHAR *src, VARCHAR *dest, size_t max_dest_len) {
    int start = 0, end = src->len - 1;
    while (start <= end && isspace((unsigned char)src->arr[start])) start++;
    while (end >= start && isspace((unsigned char)src->arr[end])) end--;
    size_t len = (end >= start) ? (end - start + 1) : 0;
    if (len > max_dest_len) len = max_dest_len;
    memcpy(dest->arr, src->arr + start, len);
    dest->len = (unsigned short)len;
}

// Uppercase
void varchar_upper(const VARCHAR *src, VARCHAR *dest, size_t max_dest_len) {
    size_t len = (src->len > max_dest_len) ? max_dest_len : src->len;
    for (size_t i = 0; i < len; i++)
        dest->arr[i] = (unsigned char)toupper(src->arr[i]);
    dest->len = (unsigned short)len;
}

// Lowercase
void varchar_lower(const VARCHAR *src, VARCHAR *dest, size_t max_dest_len) {
    size_t len = (src->len > max_dest_len) ? max_dest_len : src->len;
    for (size_t i = 0; i < len; i++)
        dest->arr[i] = (unsigned char)tolower(src->arr[i]);
    dest->len = (unsigned short)len;
}

// Move memory safely
void varchar_move(VARCHAR *dest, const VARCHAR *src, size_t max_dest_len) {
    size_t len = (src->len > max_dest_len) ? max_dest_len : src->len;
    memmove(dest->arr, src->arr, len);
    dest->len = (unsigned short)len;
}

// Set region to a char
void varchar_set(VARCHAR *v, char ch, size_t len, size_t max_len) {
    if (len > max_len) len = max_len;
    memset(v->arr, ch, len);
    v->len = (unsigned short)len;
}

// Zero out VARCHAR
void varchar_bzero(VARCHAR *v, size_t max_len) {
    memset(v->arr, 0, max_len);
    v->len = 0;
}
